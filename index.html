<!DOCTYPE html>
<html>
  <head>
      <meta charset="utf-8" />
      <title>notes</title>
      <style>.markdown-preview:not([data-use-github-style]) { padding: 2em; font-size: 1.2em; color: rgb(171, 178, 191); background-color: rgb(40, 44, 52); overflow: auto; }
.markdown-preview:not([data-use-github-style]) > :first-child { margin-top: 0px; }
.markdown-preview:not([data-use-github-style]) h1, .markdown-preview:not([data-use-github-style]) h2, .markdown-preview:not([data-use-github-style]) h3, .markdown-preview:not([data-use-github-style]) h4, .markdown-preview:not([data-use-github-style]) h5, .markdown-preview:not([data-use-github-style]) h6 { line-height: 1.2; margin-top: 1.5em; margin-bottom: 0.5em; color: rgb(255, 255, 255); }
.markdown-preview:not([data-use-github-style]) h1 { font-size: 2.4em; font-weight: 300; }
.markdown-preview:not([data-use-github-style]) h2 { font-size: 1.8em; font-weight: 400; }
.markdown-preview:not([data-use-github-style]) h3 { font-size: 1.5em; font-weight: 500; }
.markdown-preview:not([data-use-github-style]) h4 { font-size: 1.2em; font-weight: 600; }
.markdown-preview:not([data-use-github-style]) h5 { font-size: 1.1em; font-weight: 600; }
.markdown-preview:not([data-use-github-style]) h6 { font-size: 1em; font-weight: 600; }
.markdown-preview:not([data-use-github-style]) strong { color: rgb(255, 255, 255); }
.markdown-preview:not([data-use-github-style]) del { color: rgb(124, 135, 156); }
.markdown-preview:not([data-use-github-style]) a, .markdown-preview:not([data-use-github-style]) a code { color: rgb(82, 139, 255); }
.markdown-preview:not([data-use-github-style]) img { max-width: 100%; }
.markdown-preview:not([data-use-github-style]) > p { margin-top: 0px; margin-bottom: 1.5em; }
.markdown-preview:not([data-use-github-style]) > ul, .markdown-preview:not([data-use-github-style]) > ol { margin-bottom: 1.5em; }
.markdown-preview:not([data-use-github-style]) blockquote { margin: 1.5em 0px; font-size: inherit; color: rgb(124, 135, 156); border-color: rgb(75, 83, 98); border-width: 4px; }
.markdown-preview:not([data-use-github-style]) hr { margin: 3em 0px; border-top: 2px dashed rgb(75, 83, 98); background: none; }
.markdown-preview:not([data-use-github-style]) table { margin: 1.5em 0px; }
.markdown-preview:not([data-use-github-style]) th { color: rgb(255, 255, 255); }
.markdown-preview:not([data-use-github-style]) th, .markdown-preview:not([data-use-github-style]) td { padding: 0.66em 1em; border: 1px solid rgb(75, 83, 98); }
.markdown-preview:not([data-use-github-style]) code { color: rgb(255, 255, 255); background-color: rgb(58, 63, 75); }
.markdown-preview:not([data-use-github-style]) pre.editor-colors { margin: 1.5em 0px; padding: 1em; font-size: 0.92em; border-radius: 3px; background-color: rgb(49, 54, 63); }
.markdown-preview:not([data-use-github-style]) kbd { color: rgb(255, 255, 255); border-width: 1px 1px 2px; border-style: solid; border-color: rgb(75, 83, 98) rgb(75, 83, 98) rgb(62, 68, 81); border-image: initial; background-color: rgb(58, 63, 75); }
.markdown-preview[data-use-github-style] { font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif; line-height: 1.6; word-wrap: break-word; padding: 30px; font-size: 16px; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); overflow: scroll; }
.markdown-preview[data-use-github-style] > :first-child { margin-top: 0px !important; }
.markdown-preview[data-use-github-style] > :last-child { margin-bottom: 0px !important; }
.markdown-preview[data-use-github-style] a:not([href]) { color: inherit; text-decoration: none; }
.markdown-preview[data-use-github-style] .absent { color: rgb(204, 0, 0); }
.markdown-preview[data-use-github-style] .anchor { position: absolute; top: 0px; left: 0px; display: block; padding-right: 6px; padding-left: 30px; margin-left: -30px; }
.markdown-preview[data-use-github-style] .anchor:focus { outline: none; }
.markdown-preview[data-use-github-style] h1, .markdown-preview[data-use-github-style] h2, .markdown-preview[data-use-github-style] h3, .markdown-preview[data-use-github-style] h4, .markdown-preview[data-use-github-style] h5, .markdown-preview[data-use-github-style] h6 { position: relative; margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; }
.markdown-preview[data-use-github-style] h1 .octicon-link, .markdown-preview[data-use-github-style] h2 .octicon-link, .markdown-preview[data-use-github-style] h3 .octicon-link, .markdown-preview[data-use-github-style] h4 .octicon-link, .markdown-preview[data-use-github-style] h5 .octicon-link, .markdown-preview[data-use-github-style] h6 .octicon-link { display: none; color: rgb(0, 0, 0); vertical-align: middle; }
.markdown-preview[data-use-github-style] h1:hover .anchor, .markdown-preview[data-use-github-style] h2:hover .anchor, .markdown-preview[data-use-github-style] h3:hover .anchor, .markdown-preview[data-use-github-style] h4:hover .anchor, .markdown-preview[data-use-github-style] h5:hover .anchor, .markdown-preview[data-use-github-style] h6:hover .anchor { padding-left: 8px; margin-left: -30px; text-decoration: none; }
.markdown-preview[data-use-github-style] h1:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h2:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h3:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h4:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h5:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h6:hover .anchor .octicon-link { display: inline-block; }
.markdown-preview[data-use-github-style] h1 tt, .markdown-preview[data-use-github-style] h2 tt, .markdown-preview[data-use-github-style] h3 tt, .markdown-preview[data-use-github-style] h4 tt, .markdown-preview[data-use-github-style] h5 tt, .markdown-preview[data-use-github-style] h6 tt, .markdown-preview[data-use-github-style] h1 code, .markdown-preview[data-use-github-style] h2 code, .markdown-preview[data-use-github-style] h3 code, .markdown-preview[data-use-github-style] h4 code, .markdown-preview[data-use-github-style] h5 code, .markdown-preview[data-use-github-style] h6 code { font-size: inherit; }
.markdown-preview[data-use-github-style] h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
.markdown-preview[data-use-github-style] h1 .anchor { line-height: 1; }
.markdown-preview[data-use-github-style] h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
.markdown-preview[data-use-github-style] h2 .anchor { line-height: 1; }
.markdown-preview[data-use-github-style] h3 { font-size: 1.5em; line-height: 1.43; }
.markdown-preview[data-use-github-style] h3 .anchor { line-height: 1.2; }
.markdown-preview[data-use-github-style] h4 { font-size: 1.25em; }
.markdown-preview[data-use-github-style] h4 .anchor { line-height: 1.2; }
.markdown-preview[data-use-github-style] h5 { font-size: 1em; }
.markdown-preview[data-use-github-style] h5 .anchor { line-height: 1.1; }
.markdown-preview[data-use-github-style] h6 { font-size: 1em; color: rgb(119, 119, 119); }
.markdown-preview[data-use-github-style] h6 .anchor { line-height: 1.1; }
.markdown-preview[data-use-github-style] p, .markdown-preview[data-use-github-style] blockquote, .markdown-preview[data-use-github-style] ul, .markdown-preview[data-use-github-style] ol, .markdown-preview[data-use-github-style] dl, .markdown-preview[data-use-github-style] table, .markdown-preview[data-use-github-style] pre { margin-top: 0px; margin-bottom: 16px; }
.markdown-preview[data-use-github-style] hr { height: 4px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; }
.markdown-preview[data-use-github-style] ul, .markdown-preview[data-use-github-style] ol { padding-left: 2em; }
.markdown-preview[data-use-github-style] ul.no-list, .markdown-preview[data-use-github-style] ol.no-list { padding: 0px; list-style-type: none; }
.markdown-preview[data-use-github-style] ul ul, .markdown-preview[data-use-github-style] ul ol, .markdown-preview[data-use-github-style] ol ol, .markdown-preview[data-use-github-style] ol ul { margin-top: 0px; margin-bottom: 0px; }
.markdown-preview[data-use-github-style] li > p { margin-top: 16px; }
.markdown-preview[data-use-github-style] dl { padding: 0px; }
.markdown-preview[data-use-github-style] dl dt { padding: 0px; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; }
.markdown-preview[data-use-github-style] dl dd { padding: 0px 16px; margin-bottom: 16px; }
.markdown-preview[data-use-github-style] blockquote { padding: 0px 15px; color: rgb(119, 119, 119); border-left: 4px solid rgb(221, 221, 221); }
.markdown-preview[data-use-github-style] blockquote > :first-child { margin-top: 0px; }
.markdown-preview[data-use-github-style] blockquote > :last-child { margin-bottom: 0px; }
.markdown-preview[data-use-github-style] table { display: block; width: 100%; overflow: auto; word-break: keep-all; }
.markdown-preview[data-use-github-style] table th { font-weight: bold; }
.markdown-preview[data-use-github-style] table th, .markdown-preview[data-use-github-style] table td { padding: 6px 13px; border: 1px solid rgb(221, 221, 221); }
.markdown-preview[data-use-github-style] table tr { background-color: rgb(255, 255, 255); border-top: 1px solid rgb(204, 204, 204); }
.markdown-preview[data-use-github-style] table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }
.markdown-preview[data-use-github-style] img { max-width: 100%; box-sizing: border-box; }
.markdown-preview[data-use-github-style] .emoji { max-width: none; }
.markdown-preview[data-use-github-style] span.frame { display: block; overflow: hidden; }
.markdown-preview[data-use-github-style] span.frame > span { display: block; float: left; width: auto; padding: 7px; margin: 13px 0px 0px; overflow: hidden; border: 1px solid rgb(221, 221, 221); }
.markdown-preview[data-use-github-style] span.frame span img { display: block; float: left; }
.markdown-preview[data-use-github-style] span.frame span span { display: block; padding: 5px 0px 0px; clear: both; color: rgb(51, 51, 51); }
.markdown-preview[data-use-github-style] span.align-center { display: block; overflow: hidden; clear: both; }
.markdown-preview[data-use-github-style] span.align-center > span { display: block; margin: 13px auto 0px; overflow: hidden; text-align: center; }
.markdown-preview[data-use-github-style] span.align-center span img { margin: 0px auto; text-align: center; }
.markdown-preview[data-use-github-style] span.align-right { display: block; overflow: hidden; clear: both; }
.markdown-preview[data-use-github-style] span.align-right > span { display: block; margin: 13px 0px 0px; overflow: hidden; text-align: right; }
.markdown-preview[data-use-github-style] span.align-right span img { margin: 0px; text-align: right; }
.markdown-preview[data-use-github-style] span.float-left { display: block; float: left; margin-right: 13px; overflow: hidden; }
.markdown-preview[data-use-github-style] span.float-left span { margin: 13px 0px 0px; }
.markdown-preview[data-use-github-style] span.float-right { display: block; float: right; margin-left: 13px; overflow: hidden; }
.markdown-preview[data-use-github-style] span.float-right > span { display: block; margin: 13px auto 0px; overflow: hidden; text-align: right; }
.markdown-preview[data-use-github-style] code, .markdown-preview[data-use-github-style] tt { padding: 0.2em 0px; margin: 0px; font-size: 85%; background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; }
.markdown-preview[data-use-github-style] code::before, .markdown-preview[data-use-github-style] tt::before, .markdown-preview[data-use-github-style] code::after, .markdown-preview[data-use-github-style] tt::after { letter-spacing: -0.2em; content: " "; }
.markdown-preview[data-use-github-style] code br, .markdown-preview[data-use-github-style] tt br { display: none; }
.markdown-preview[data-use-github-style] del code { text-decoration: inherit; }
.markdown-preview[data-use-github-style] pre > code { padding: 0px; margin: 0px; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0px; }
.markdown-preview[data-use-github-style] .highlight { margin-bottom: 16px; }
.markdown-preview[data-use-github-style] .highlight pre, .markdown-preview[data-use-github-style] pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border-radius: 3px; }
.markdown-preview[data-use-github-style] .highlight pre { margin-bottom: 0px; word-break: normal; }
.markdown-preview[data-use-github-style] pre { word-wrap: normal; }
.markdown-preview[data-use-github-style] pre code, .markdown-preview[data-use-github-style] pre tt { display: inline; max-width: initial; padding: 0px; margin: 0px; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0px; }
.markdown-preview[data-use-github-style] pre code::before, .markdown-preview[data-use-github-style] pre tt::before, .markdown-preview[data-use-github-style] pre code::after, .markdown-preview[data-use-github-style] pre tt::after { content: normal; }
.markdown-preview[data-use-github-style] kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: rgb(85, 85, 85); vertical-align: middle; background-color: rgb(252, 252, 252); border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204) rgb(204, 204, 204) rgb(187, 187, 187); border-image: initial; border-radius: 3px; box-shadow: rgb(187, 187, 187) 0px -1px 0px inset; }
.markdown-preview[data-use-github-style] a { color: rgb(51, 122, 183); }
.markdown-preview[data-use-github-style] code { color: inherit; }
.markdown-preview[data-use-github-style] pre.editor-colors { padding: 0.8em 1em; margin-bottom: 1em; font-size: 0.85em; border-radius: 4px; overflow: auto; }
.scrollbars-visible-always .markdown-preview pre.editor-colors .vertical-scrollbar, .scrollbars-visible-always .markdown-preview pre.editor-colors .horizontal-scrollbar { visibility: hidden; }
.scrollbars-visible-always .markdown-preview pre.editor-colors:hover .vertical-scrollbar, .scrollbars-visible-always .markdown-preview pre.editor-colors:hover .horizontal-scrollbar { visibility: visible; }
.markdown-preview .task-list-item-checkbox { position: absolute; margin: 0.25em 0px 0px -1.4em; }
.bracket-matcher .region {
  border-bottom: 1px dotted lime;
  position: absolute;
}

.spell-check-misspelling .region {
  border-bottom: 2px dotted rgba(255, 51, 51, 0.75);
}
.spell-check-corrections {
  width: 25em !important;
}

pre.editor-colors {
  background-color: #282c34;
  color: #abb2bf;
}
pre.editor-colors .line.cursor-line {
  background-color: rgba(153, 187, 255, 0.04);
}
pre.editor-colors .invisible {
  color: #abb2bf;
}
pre.editor-colors .cursor {
  border-left: 2px solid #528bff;
}
pre.editor-colors .selection .region {
  background-color: #3e4451;
}
pre.editor-colors .bracket-matcher .region {
  border-bottom: 1px solid #528bff;
  box-sizing: border-box;
}
pre.editor-colors .invisible-character {
  color: rgba(171, 178, 191, 0.15);
}
pre.editor-colors .indent-guide {
  color: rgba(171, 178, 191, 0.15);
}
pre.editor-colors .wrap-guide {
  background-color: rgba(171, 178, 191, 0.15);
}
pre.editor-colors .find-result .region.region.region,
pre.editor-colors .current-result .region.region.region {
  border-radius: 2px;
  background-color: rgba(82, 139, 255, 0.24);
  transition: border-color 0.4s;
}
pre.editor-colors .find-result .region.region.region {
  border: 2px solid transparent;
}
pre.editor-colors .current-result .region.region.region {
  border: 2px solid #528bff;
  transition-duration: .1s;
}
pre.editor-colors .gutter .line-number {
  color: #636d83;
  -webkit-font-smoothing: antialiased;
}
pre.editor-colors .gutter .line-number.cursor-line {
  color: #abb2bf;
  background-color: #2c313a;
}
pre.editor-colors .gutter .line-number.cursor-line-no-selection {
  background-color: transparent;
}
pre.editor-colors .gutter .line-number .icon-right {
  color: #abb2bf;
}
pre.editor-colors .gutter:not(.git-diff-icon) .line-number.git-line-removed.git-line-removed::before {
  bottom: -3px;
}
pre.editor-colors .gutter:not(.git-diff-icon) .line-number.git-line-removed::after {
  content: "";
  position: absolute;
  left: 0px;
  bottom: 0px;
  width: 25px;
  border-bottom: 1px dotted rgba(224, 82, 82, 0.5);
  pointer-events: none;
}
pre.editor-colors .gutter .line-number.folded,
pre.editor-colors .gutter .line-number:after,
pre.editor-colors .fold-marker:after {
  color: #abb2bf;
}
.syntax--comment {
  color: #5c6370;
  font-style: italic;
}
.syntax--comment .syntax--markup.syntax--link {
  color: #5c6370;
}
.syntax--entity.syntax--name.syntax--type {
  color: #e5c07b;
}
.syntax--entity.syntax--other.syntax--inherited-class {
  color: #98c379;
}
.syntax--keyword {
  color: #c678dd;
}
.syntax--keyword.syntax--control {
  color: #c678dd;
}
.syntax--keyword.syntax--operator {
  color: #abb2bf;
}
.syntax--keyword.syntax--other.syntax--special-method {
  color: #61afef;
}
.syntax--keyword.syntax--other.syntax--unit {
  color: #d19a66;
}
.syntax--storage {
  color: #c678dd;
}
.syntax--storage.syntax--type.syntax--annotation,
.syntax--storage.syntax--type.syntax--primitive {
  color: #c678dd;
}
.syntax--storage.syntax--modifier.syntax--package,
.syntax--storage.syntax--modifier.syntax--import {
  color: #abb2bf;
}
.syntax--constant {
  color: #d19a66;
}
.syntax--constant.syntax--variable {
  color: #d19a66;
}
.syntax--constant.syntax--character.syntax--escape {
  color: #56b6c2;
}
.syntax--constant.syntax--numeric {
  color: #d19a66;
}
.syntax--constant.syntax--other.syntax--color {
  color: #56b6c2;
}
.syntax--constant.syntax--other.syntax--symbol {
  color: #56b6c2;
}
.syntax--variable {
  color: #e06c75;
}
.syntax--variable.syntax--interpolation {
  color: #be5046;
}
.syntax--variable.syntax--parameter {
  color: #abb2bf;
}
.syntax--string {
  color: #98c379;
}
.syntax--string.syntax--regexp {
  color: #56b6c2;
}
.syntax--string.syntax--regexp .syntax--source.syntax--ruby.syntax--embedded {
  color: #e5c07b;
}
.syntax--string.syntax--other.syntax--link {
  color: #e06c75;
}
.syntax--punctuation.syntax--definition.syntax--comment {
  color: #5c6370;
}
.syntax--punctuation.syntax--definition.syntax--method-parameters,
.syntax--punctuation.syntax--definition.syntax--function-parameters,
.syntax--punctuation.syntax--definition.syntax--parameters,
.syntax--punctuation.syntax--definition.syntax--separator,
.syntax--punctuation.syntax--definition.syntax--seperator,
.syntax--punctuation.syntax--definition.syntax--array {
  color: #abb2bf;
}
.syntax--punctuation.syntax--definition.syntax--heading,
.syntax--punctuation.syntax--definition.syntax--identity {
  color: #61afef;
}
.syntax--punctuation.syntax--definition.syntax--bold {
  color: #e5c07b;
  font-weight: bold;
}
.syntax--punctuation.syntax--definition.syntax--italic {
  color: #c678dd;
  font-style: italic;
}
.syntax--punctuation.syntax--section.syntax--embedded {
  color: #be5046;
}
.syntax--punctuation.syntax--section.syntax--method,
.syntax--punctuation.syntax--section.syntax--class,
.syntax--punctuation.syntax--section.syntax--inner-class {
  color: #abb2bf;
}
.syntax--support.syntax--class {
  color: #e5c07b;
}
.syntax--support.syntax--type {
  color: #56b6c2;
}
.syntax--support.syntax--function {
  color: #56b6c2;
}
.syntax--support.syntax--function.syntax--any-method {
  color: #61afef;
}
.syntax--entity.syntax--name.syntax--function {
  color: #61afef;
}
.syntax--entity.syntax--name.syntax--class,
.syntax--entity.syntax--name.syntax--type.syntax--class {
  color: #e5c07b;
}
.syntax--entity.syntax--name.syntax--section {
  color: #61afef;
}
.syntax--entity.syntax--name.syntax--tag {
  color: #e06c75;
}
.syntax--entity.syntax--other.syntax--attribute-name {
  color: #d19a66;
}
.syntax--entity.syntax--other.syntax--attribute-name.syntax--id {
  color: #61afef;
}
.syntax--meta.syntax--class {
  color: #e5c07b;
}
.syntax--meta.syntax--class.syntax--body {
  color: #abb2bf;
}
.syntax--meta.syntax--method-call,
.syntax--meta.syntax--method {
  color: #abb2bf;
}
.syntax--meta.syntax--definition.syntax--variable {
  color: #e06c75;
}
.syntax--meta.syntax--link {
  color: #d19a66;
}
.syntax--meta.syntax--require {
  color: #61afef;
}
.syntax--meta.syntax--selector {
  color: #c678dd;
}
.syntax--meta.syntax--separator {
  background-color: #373b41;
  color: #abb2bf;
}
.syntax--meta.syntax--tag {
  color: #abb2bf;
}
.syntax--underline {
  text-decoration: underline;
}
.syntax--none {
  color: #abb2bf;
}
.syntax--invalid.syntax--deprecated {
  color: #523d14 !important;
  background-color: #e0c285 !important;
}
.syntax--invalid.syntax--illegal {
  color: white !important;
  background-color: #e05252 !important;
}
.syntax--markup.syntax--bold {
  color: #d19a66;
  font-weight: bold;
}
.syntax--markup.syntax--changed {
  color: #c678dd;
}
.syntax--markup.syntax--deleted {
  color: #e06c75;
}
.syntax--markup.syntax--italic {
  color: #c678dd;
  font-style: italic;
}
.syntax--markup.syntax--heading {
  color: #e06c75;
}
.syntax--markup.syntax--heading .syntax--punctuation.syntax--definition.syntax--heading {
  color: #61afef;
}
.syntax--markup.syntax--link {
  color: #56b6c2;
}
.syntax--markup.syntax--inserted {
  color: #98c379;
}
.syntax--markup.syntax--quote {
  color: #d19a66;
}
.syntax--markup.syntax--raw {
  color: #98c379;
}
.syntax--source.syntax--c .syntax--keyword.syntax--operator {
  color: #c678dd;
}
.syntax--source.syntax--cpp .syntax--keyword.syntax--operator {
  color: #c678dd;
}
.syntax--source.syntax--cs .syntax--keyword.syntax--operator {
  color: #c678dd;
}
.syntax--source.syntax--css .syntax--property-name,
.syntax--source.syntax--css .syntax--property-value {
  color: #828997;
}
.syntax--source.syntax--css .syntax--property-name.syntax--support,
.syntax--source.syntax--css .syntax--property-value.syntax--support {
  color: #abb2bf;
}
.syntax--source.syntax--elixir .syntax--source.syntax--embedded.syntax--source {
  color: #abb2bf;
}
.syntax--source.syntax--elixir .syntax--constant.syntax--language,
.syntax--source.syntax--elixir .syntax--constant.syntax--numeric,
.syntax--source.syntax--elixir .syntax--constant.syntax--definition {
  color: #61afef;
}
.syntax--source.syntax--elixir .syntax--variable.syntax--definition,
.syntax--source.syntax--elixir .syntax--variable.syntax--anonymous {
  color: #c678dd;
}
.syntax--source.syntax--elixir .syntax--quoted {
  color: #98c379;
}
.syntax--source.syntax--elixir .syntax--keyword.syntax--special-method,
.syntax--source.syntax--elixir .syntax--embedded.syntax--section,
.syntax--source.syntax--elixir .syntax--embedded.syntax--source.syntax--empty {
  color: #e06c75;
}
.syntax--source.syntax--elixir .syntax--readwrite.syntax--module .syntax--punctuation {
  color: #e06c75;
}
.syntax--source.syntax--elixir .syntax--regexp.syntax--section,
.syntax--source.syntax--elixir .syntax--regexp.syntax--string {
  color: #be5046;
}
.syntax--source.syntax--elixir .syntax--separator,
.syntax--source.syntax--elixir .syntax--keyword.syntax--operator {
  color: #d19a66;
}
.syntax--source.syntax--elixir .syntax--variable.syntax--constant {
  color: #e5c07b;
}
.syntax--source.syntax--elixir .syntax--array,
.syntax--source.syntax--elixir .syntax--scope,
.syntax--source.syntax--elixir .syntax--section {
  color: #828997;
}
.syntax--source.syntax--gfm .syntax--markup {
  -webkit-font-smoothing: auto;
}
.syntax--source.syntax--gfm .syntax--link .syntax--entity {
  color: #61afef;
}
.syntax--source.syntax--go .syntax--storage.syntax--type.syntax--string {
  color: #c678dd;
}
.syntax--source.syntax--ini .syntax--keyword.syntax--other.syntax--definition.syntax--ini {
  color: #e06c75;
}
.syntax--source.syntax--java .syntax--storage.syntax--modifier.syntax--import {
  color: #e5c07b;
}
.syntax--source.syntax--java .syntax--storage.syntax--type {
  color: #e5c07b;
}
.syntax--source.syntax--java .syntax--keyword.syntax--operator.syntax--instanceof {
  color: #c678dd;
}
.syntax--source.syntax--java-properties .syntax--meta.syntax--key-pair {
  color: #e06c75;
}
.syntax--source.syntax--java-properties .syntax--meta.syntax--key-pair > .syntax--punctuation {
  color: #abb2bf;
}
.syntax--source.syntax--js .syntax--keyword.syntax--operator {
  color: #56b6c2;
}
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--delete,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--in,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--of,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--instanceof,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--new,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--typeof,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--void {
  color: #c678dd;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--string.syntax--quoted.syntax--json {
  color: #e06c75;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation.syntax--string {
  color: #e06c75;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation {
  color: #98c379;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--constant.syntax--language.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--constant.syntax--language.syntax--json {
  color: #56b6c2;
}
.syntax--source.syntax--ruby .syntax--constant.syntax--other.syntax--symbol > .syntax--punctuation {
  color: inherit;
}
.syntax--source.syntax--python .syntax--keyword.syntax--operator.syntax--logical.syntax--python {
  color: #c678dd;
}
.syntax--source.syntax--python .syntax--variable.syntax--parameter {
  color: #d19a66;
}
</style>
  </head>
  <body class='markdown-preview' data-use-github-style><div style="text-align:center">
<img src="https://www.hyperledger.org/wp-content/uploads/2016/09/logo_hl_new.png" alt="logo">
</div>

<hr>
<p>Means:</p>
<ul>
<li>using distributed ledger technologies in a permission setting,</li>
<li>using smart contracts to automate various business processes,</li>
<li>building a really exciting new world, secure, trustworthy information
systems and automation of business processes.</li>
</ul>
<hr>
<h2 id="learning-objectives">Learning Objectives</h2>
<ul>
<li><label>
  <input type="checkbox" class="task-list-item-checkbox">
   Describe Business Blockchain and Distributed Ledger Technologies.
</label></li>
<li><label>
  <input type="checkbox" class="task-list-item-checkbox">
   Gain familiarity with current Hyperledger projects and cross-industry use cases.
</label></li>
<li><label>
  <input type="checkbox" class="task-list-item-checkbox">
   Perform clean installations of the Hyperledger Sawtooth and Hyperledger Fabric frameworks.
</label></li>
<li><label>
  <input type="checkbox" class="task-list-item-checkbox">
   Explore a sample use case/application in the context of the Hyperledger Sawtooth and Hyperledger Fabric frameworks.
</label></li>
<li><label>
  <input type="checkbox" class="task-list-item-checkbox">
   Build simple applications on top of Hyperledger Sawtooth and Hyperledger Fabric.
</label></li>
<li><label>
  <input type="checkbox" class="task-list-item-checkbox">
   Become involved in and contribute to the open source Hyperledger projects
</label></li>
</ul>
<hr>
<p>It aims at advancing and promoting cross-industry blockchain technologies to ensure accountability, transparency, and trust among business partners. As a result, Hyperledger makes business network and transactions more efficient.</p>
<h1 id="chapter-1-discovering-blockchain-technologies-distributed-ledger-technology-dlt-">Chapter 1. Discovering Blockchain Technologies &gt; Distributed Ledger Technology (DLT)</h1>
<p>In summary, distributed ledger technology generally consists of three basic components:</p>
<ul>
<li><p>A <strong>data model</strong> that captures the current state of the ledger.</p>
</li>
<li><p>A <strong>language of transactions</strong> that changes the ledger state.</p>
</li>
<li><p>A <strong>protocol</strong> used to build consensus among participants around which transactions will be accepted, and in what order, by the ledger.</p>
</li>
</ul>
<p>A blockchain is a peer-to-peer distributed ledger, forged by consensus, combined with a system for smart contracts and other assistive technologies.
Together, these can be used to build a new generation of transactional applications that establish trust, accountability, and transparency at their core.</p>
<p><strong>Smart contracts</strong> are simply computer programs that execute predefined actions when certain conditions within the system are met.</p>
<p><strong>Consensus</strong> refers to a system of ensuring that parties agree to a certain state of the system as the true state.</p>
<hr>
<h1 id="chapter-2-introduction-to-hyperledger">Chapter 2. Introduction to Hyperledger</h1>
<div style="text-align: center">
<img src="https://d37djvu3ytnwxt.cloudfront.net/assets/courseware/v1/7adde90b7e1bca2dd7ac50e437291be0/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/modular_umbrella.jpg" alt="umbrella">
</div>
Hyperledger business blockchain frameworks are used to build enterprise blockchains for a consortium of organizations. They are different than public ledgers like the Bitcoin blockchain and Ethereum. The Hyperledger frameworks include:

- An append-only distributed ledger
- A consensus algorithm for agreeing to changes in the ledger
- Privacy of transactions through permissioned access
- Smart contracts to process transaction requests.

<div style="text-align: center">
<img src="https://d37djvu3ytnwxt.cloudfront.net/assets/courseware/v1/0747265232da64643d21679294cbbe19/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Components_of_blockchain.jpg" alt="">
</div>

<h3 id="hyperledger-iroha">Hyperledger Iroha</h3>
<p>Is a blockchain framework contributed by Soramitsu, Hitachi, NTT Data, and Colu. Hyperledger Iroha is designed to be simple and easy to incorporate into infrastructure projects requiring distributed ledger technology. Hyperledger Iroha emphasizes mobile application development with client libraries for Android and iOS, making it distinct from other Hyperledger frameworks. Inspired by Hyperledger Fabric, Hyperledger Iroha seeks to complement Hyperledger Fabric and Hyperledger Sawtooth, while providing a development environment for C++ developers to contribute to Hyperledger.</p>
<p>In conclusion, Hyperledger Iroha features a simple construction, modern, domain-driven C++ design, along with the consensus algorithm YAC.</p>
<h3 id="hyperledger-sawtooth">Hyperledger Sawtooth</h3>
<p>Hyperledger Sawtooth, contributed by Intel, is a blockchain framework that utilizes a modular platform for building, deploying, and running distributed ledgers. Distributed ledger solutions built with Hyperledger Sawtooth can utilize various consensus algorithms based on the size of the network. By default, it uses the Proof of Elapsed Time (PoET) consensus algorithm, which provides the scalability of the Bitcoin blockchain without the high energy consumption. PoET allows for a highly scalable network of validator nodes. Hyperledger Sawtooth is designed for versatility, with support for both permissioned and permissionless deployments.</p>
<h3 id="hyperledger-fabric">Hyperledger Fabric</h3>
<p>Hyperledger Fabric was the first proposal for a codebase, combining previous work done by Digital Asset Holdings, Blockstream&#39;s libconsensus, and IBM&#39;s OpenBlockchain. Hyperledger Fabric provides a modular architecture, which allows components such as consensus and membership services to be plug-and-play. Hyperledger Fabric is revolutionary in allowing entities to conduct confidential transactions without passing information through a central authority. This is accomplished through different channels that run within the network, as well as the division of labor that characterizes the different nodes within the network. Lastly, it is important to remember that, unlike Bitcoin, which is a public chain, Hyperledger Fabric supports permissioned deployments.</p>
<p>&quot;If you have a large blockchain network and you want to share data with only certain parties, you can create a private channel with just those participants. It is the most distinctive thing about Fabric right now.&quot;</p>
<ul>
<li>Brian Behlendorf, Executive Director of Hyperledger, The Linux Foundation</li>
</ul>
<h3 id="hyperledger-indy">Hyperledger Indy</h3>
<p>Hyperledger Indy is a distributed ledger purpose-built for decentralized identity. Hyperledger Indy&#39;s goal is to achieve this by developing a set of</p>
<p>&quot;(...) decentralized identity specs and artifacts that are independent of any particular ledger and will enable interoperability across any DLT that supports them.&quot;</p>
<h3 id="hyperledger-burrow">Hyperledger Burrow</h3>
<p>Formally known as eris-db, Hyperledger Burrow was released in December 2014. Currently under incubation, Hyperledger Burrow is a permissionable smart contract machine that provides a modular blockchain client with a permissioned smart contract interpreter built- in part to the specification of the Ethereum Virtual Machine (EVM). It is the only available Apache-licensed EVM implementation.</p>
<p>Following are the major components of Burrow:</p>
<ul>
<li>The Gateway provides interfaces for systems integration and user interfaces</li>
<li>The Smart contract application engine facilitates integration of complex business logic</li>
<li>The Consensus Engine serves the dual purpose of:<ul>
<li>a. Maintaining the networking stack between the nodes, and,</li>
<li>b. Ordering transactions</li>
</ul>
</li>
<li>The Application Blockchain Interface (ABCI) provides interface specification for the consensus engine and smart contract application engine to connect.</li>
</ul>
<h3 id="hyperledger-modules">Hyperledger modules</h3>
<h4 id="cello">Cello</h4>
<p>For businesses that want to deploy Blockchain-as-a-Service, Hyperledger Cello provides a toolkit that fulfills this need. Particularly for lean businesses and small enterprises, who want to reduce or eliminate the effort required in creating, managing, and terminating blockchains, Hyperledger Cello allows blockchains deployment to the cloud. Operators can create and manage such blockchains through a dashboard, and users (typically, chaincode developers) can obtain a blockchain instance immediately.</p>
<p>As a Hyperledger module, &quot;Cello aims to bring the on-demand &#39;as-a-service&#39; deployment model to the blockchain ecosystem&quot;, thus helping in furthering the development and deployment of Hyperledger&#39;s frameworks. Hyperledger Cello was initially contributed by IBM, with sponsors from Soramitsu, Huawei, and Intel.</p>
<p>Application developers and system administrators using Cello can provision and maintain Hyperledger networks. For instance, you can create a group of distributed ledger networks in virtual clouds known as &#39;container clusters&#39;, and then, manage and monitor those networks with a configurable dashboard. Additionally, you can build a Blockchain-as-a-Service (BaaS) platform.</p>
<h5 id="cello-s-architecture">Cello’s Architecture</h5>
<p>Cello leverages the Docker APIs to manage the blockchain clusters in remote hosts, including physical servers and virtual machines. Hence Cello can be easily deployed to Cloud environments that provide virtual machines on demand.
The design architecture is as follows:</p>
<ul>
<li>Orchestration Engine: Core to handle resource management and workload scheduling, which is mainly implemented in Python;</li>
<li>Dashboard: Operational interface, implemented with JavaScript;</li>
<li>Restful Server: Operational interface, which is implemented with Python;</li>
<li>Drivers: Currently we utilize Docker API lib, to support native host and Swarm cluster The driver layer is designed to be pluggable to support more types in future;</li>
<li>Tools: We have also designed several tools to handle tasks like monitoring and logging, which are mainly implemented in Golang. However, the framework is pluggable, hence we can also integrate existing open-source tools.
<div style="text-align: center">
<img src="https://www.hyperledger.org/wp-content/uploads/2017/01/architecture-768x282.png" alt="arch">
</div>
<a href="https://www.hyperledger.org/blog/2017/01/17/hyperledger-says-hello-to-cello">more info</a></li>
</ul>
<h4 id="composer">Composer</h4>
<p>Hyperledger Composer provides a suite of tools for building blockchain business networks. These tools allow you to:</p>
<p>Model your business blockchain network
Generate REST APIs for interacting with your blockchain network
Generate a skeleton Angular application.</p>
<h4 id="explorer">Explorer</h4>
<p>Hyperledger Explorer is a tool for visualizing blockchain operations. It is the first ever blockchain explorer for permissioned ledgers, allowing anyone to explore the distributed ledger projects being created by Hyperledger&#39;s members from the inside, without compromising their privacy. The project was contributed by DTCC, Intel, and IBM.</p>
<p>Designed to create a user-friendly web application, Hyperledger Explorer can view, invoke, deploy, or query:</p>
<ul>
<li>Blocks</li>
<li>Transactions and associated data</li>
<li>Network information (name, status, list of nodes)</li>
<li>Smart contracts (chain codes and transaction families)</li>
<li>Other relevant information stored in the ledger.</li>
</ul>
<hr>
<h1 id="chapter-3-the-promise-of-business-blockchain-technologies">Chapter 3. The Promise of Business Blockchain Technologies</h1>
<h3 id="business-blockchain-technologies-overview">Business Blockchain Technologies Overview</h3>
<p>Blockchain is a new data structure with an automated way to enforce trust among participants. Consensus algorithms ensure that all participants agree on the data stored within the blockchain. Blockchain opens the door to disrupt any industry that relies on a central authority to confirm authenticity. It also allows independent, and even competing organizations, to share information to gain efficiencies across an industry.</p>
<p>In permissioned blockchains, a consortium of organizations are responsible for authenticating and controlling the participants in a blockchain. In public blockchains, no central authority or administration is required to exchange data. Blockchains can drive business innovation through controlled data-sharing networks for industry consortiums.</p>
<p>The promise of distributed ledger technologies (DLT) to simplify and automate key work functions has many industries taking notice. Businesses recognize the efficiency gains from transitioning from closed and proprietary solutions to standard open source capabilities, such as Hyperledger business blockchain technologies. Several common project features of blockchain applications are taking shape as the technology matures.</p>
<h3 id="when-to-use-a-blockchain">When to use a Blockchain</h3>
<p>There are certain factors to consider when evaluating blockchain distributed ledger technology for your business. How many participants are in your system? What is the geographical distribution of the participants? What sort of performance requirements do you have? Defining the rules, risks, and responsibilities of each party in your blockchain system is useful as you consider transferring a database to a decentralized environment such as one of the Hyperledger frameworks. Blockchain is best suited for business applications where one or more of the following conditions apply:</p>
<ul>
<li>There is a need for a shared common database</li>
<li>The parties involved with the process have conflicting incentives, or do not have trust among participants</li>
<li>There are multiple parties involved or writers to a database</li>
<li>There are currently trusted third parties involved in the process that facilitate interactions between multiple parties who must trust the third party. This could include escrow services, data feed providers, licensing authorities, or a notary public</li>
<li>Cryptography is currently being used or should be used. Cryptography facilitates data confidentiality, data integrity, authentication, and non-repudiation</li>
<li>Data for a business process is being entered into many different databases along the lifecycle of the process. It is important that this data is consistent across all entities, and/or digitization of such a process is desired</li>
<li>There are uniform rules governing participants in the system</li>
<li>Decision making of the parties is transparent, rather than confidential</li>
<li>There is a need for an objective, immutable history or log of facts for parties’ reference</li>
<li>Transaction frequency does not exceed 10,000 transactions per second.</li>
</ul>
<h3 id="when-not-to-use-blockchain">When not to use Blockchain</h3>
<p>Blockchain technology is a powerful tool, but it is not always the right tool for the job at hand. If you are contemplating using blockchain technology, be sure to evaluate the problem fully. The following conditions are not currently well suited to blockchain-based solutions:</p>
<ul>
<li>The process involves confidential data</li>
<li>The process stores a lot of static data, or the data is quite large</li>
<li>Rules of transactions change frequently</li>
<li>The use of external services to gather/store data</li>
</ul>
<hr>
<h1 id="chapter-4-technical-requirements">Chapter 4. Technical Requirements</h1>
<p>You have to have the following features installed on your computer: <strong>cURL</strong>, <strong>Node.js</strong>, <strong>npm</strong> package manager, <strong>Go Language</strong>, <strong>Docker</strong>, and <strong>Docker Compose</strong>, and, if you are a Windows user, VirtualBox.</p>
<p>Fast solution:</p>
<div style="text-align: center">
<a href="https://github.com/ccebrecos/hyperledger-dependencies">bash script</a>
</div>

<hr>
<h1 id="chapter-5-introduction-to-hyperledger-iroha">Chapter 5. Introduction to Hyperledger Iroha</h1>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/94f08731c2a2a792a7a20c298839aa38/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Iroha_3_sm.png" alt="">
</div>

<p>Hyperledger Iroha is a blockchain framework, and one of the Hyperledger projects hosted by The Linux Foundation. Hyperledger Iroha is designed to be simple and easy to incorporate into infrastructure projects requiring distributed ledger technology. Hyperledger Iroha features a simple construction, modern, domain-driven C++ design, emphasis on mobile application development, and the YAC consensus algorithm.</p>
<h3 id="goals">Goals</h3>
<ol>
<li>Provide an environment for C++ developers to contribute to Hyperledger.</li>
<li>Provide infrastructure for mobile and web application support.</li>
<li>Provide a framework to introduce APIs and a new consensus algorithm that can potentially be incorporated into other frameworks in the future.</li>
</ol>
<h3 id="architecture">Architecture</h3>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/cb033d180ecb4eb288f2f0a489195e6c/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Iroha-architecture.png" alt="iroha-arch">
</div>

<p>The components are:</p>
<ul>
<li><strong>Model</strong> classes are system entities.</li>
<li><strong>Torii</strong> (gate) provides the input and output interfaces for clients. It is a single <a href="https://grpc.io/">gRPC</a> server that is used by clients to interact with peers through the network. The client&#39;s RPC call is non-blocking, making Torii an asynchronous server. Both commands (transactions) and queries (read access) are performed through this interface.</li>
<li><strong>Network</strong> encompasses interaction with the network of peers.</li>
<li><strong>Consensus</strong> is in charge of peers agreeing on chain content in the network. The consensus mechanism used by Iroha is YAC (Yet Another Consensus), which is a practical byzantine fault-tolerant algorithm based on voting for block hash.</li>
<li><strong>Simulator</strong> generates a temporary snapshot of storage to validate transactions by executing them against this snapshot and forming a verified proposal, which consists only of valid transactions.</li>
<li><strong>Validator</strong> classes check business rules and validity (correct format) of transactions or queries. There are two distinct types of validation that occur in Hyperledger Iroha:<ul>
<li><strong>Stateless validation</strong> is a quicker form of validation, that performs schema and signature checks of the transaction.</li>
<li><strong>Stateful validation</strong> is a slower form of validation, that checks the permissions and the current world state view, which is the latest and most actual state of the chain, to see if desired business rules and policies are possible. For example, does an account have enough funds to transfer?</li>
</ul>
</li>
<li><strong>Synchronizer</strong> helps to synchronize new peers in the system or temporarily disconnected peers.</li>
<li><strong>Ametsuchi</strong> is the ledger block storage which consists of a block index (currently Redis), block store (currently flat files), and a world state view component (currently PostgreSQL).</li>
</ul>
<h3 id="participants">Participants</h3>
<ul>
<li><strong>Clients</strong> are able to:<ol>
<li>Query data that they have access/permission to</li>
<li>Perform a state-changing action, &#39;transaction&#39;, which consists of atomic operations, called &#39;commands&#39;. For example, in a single transaction, a user can transfer funds to three people (three separate commands). But, if he/she does not have enough funds to cover for all, the whole transaction will be rejected.</li>
</ol>
</li>
<li><strong>Peers</strong> maintain the current state and their own copy of the shared ledger. A peer is a single entity in the network, and has an address, identity, and trust. Hyperledger Iroha is designed so that a single peer may be a single computer or scaled for a cluster, meaning different computers are used for ledger storage, indices, validation, and peer-to-peer logic.</li>
<li><strong>Ordering</strong> service orders transactions into a known order. There are a few options for the algorithm used by the ordering service. Kafka is considered a good candidate. It is important to mention that if Kafka, or any other distributed solution is used, that it be clustered; otherwise, this will result in a single point of failure.</li>
</ul>
<h3 id="transaction-flow">Transaction flow</h3>
<p><strong>Step 1:</strong> A client creates and sends a transaction to the Torii gate, which routes the transaction to a peer that is responsible for performing stateless validation.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/31cba94d9a190c0a12ab6bac4c891e14/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Step_1_of_Iroha_Transaction_Flow.png" alt="Step 1 of Iroha Transaction Flow">
</div>

<p><strong>Step 2:</strong> After the peer performs stateless validation, the transaction is first sent to the ordering gate, which is responsible for choosing the right strategy of connection to the ordering service.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/21102f3a868cc94b8157d7871ca30192/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Step_2_of_Iroha_Transaction_Flow.png" alt="Step 2 of Iroha Transaction Flow">
</div>

<p><strong>Step 3:</strong> The ordering service puts transactions into order and forwards them to peers in the consensus network in the form of proposals. A proposal is an unsigned block shared by the ordering service, that contains a batch of ordered transactions. Proposals are only forwarded when the ordering service has accumulated enough transactions, or a certain amount of time has elapsed since the last proposal. This prevents the ordering service from sending empty proposals.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/dd7b06c38b34545769fb70f4e5a1a61a/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Step_3_of_Iroha_Transaction_Flow.png" alt="Step 3 of Iroha Transaction Flow">
</div>

<p><strong>Step 4:</strong> Each peer verifies the proposal’s contents (stateful validation) in the Simulator and creates a block which consists only of verified transactions. This block is then sent to the consensus gate which performs YAC consensus logic.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/91303543f6393c61426a9b216083bed8/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Step_4_of_Iroha_transaction_flow.png" alt="Step 4 of Iroha transaction flow">
</div>

<p><strong>Step 5:</strong> An ordered list of peers is determined, and a leader is elected based on the YAC consensus logic. Each peer casts a vote by signing and sending their proposed block to the leader.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/00da4d62048b9bdf0b331629946b3573/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Step_5_of_Iroha_transaction_flow.png" alt="Step 5 of Iroha transaction flow">
</div>

<p><strong>Step 6:</strong> If the leader receives enough signed proposed blocks (i.e. more than two thirds of the peers), then it starts to send a commit message, indicating that this block should be applied to the chain of each peer participating in the consensus. Once the commit message has been sent, the proposed block becomes the next block in the chain of every peer via the synchronizer.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/118a771edf63220195e924a7154eaedd/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Step_6_of_Iroha_Transaction_flow.png" alt="Step 6 of the Iroha transaction flow">
</div>

<h3 id="yac-steps-to-successful-consensus">YAC - Steps to Successful Consensus</h3>
<p><strong>Step 1:</strong> The ordering service shares a proposal to all peers. A <strong>proposal</strong> is an unsigned block created and shared to peers in the network by the ordering service. It contains a batch of ordered transactions.</p>
<p><strong>Step 2:</strong> Peers calculate the hash of a verified proposal and sign it. The resulting <strong>&lt; Hash, Signature&gt;</strong> tuple is called a <strong>vote</strong>.</p>
<p><strong>Step 3:</strong> Based on the hashes created in the previous step, each peer computes an ordering list or order of peers. To do this, the ordering function will need to have knowledge of all the peers voting in the network, and is based on the hash of the proposed block. The first peer in the list is called the <strong>leader</strong>. The leader is responsible for collecting votes from other peers and sending the commit message.</p>
<p><strong>Step 4:</strong> Each peer votes. The leader collects all the votes and determines the supermajority of votes for a certain hash. The leader sends a commit message that contains the votes of the committing block. This response is called a <strong>commit</strong>.</p>
<p><strong>Step 5:</strong> After receiving the commit, the peers verify the commit and apply the block to the ledger. At this point, consensus is complete.</p>
<p>One of the main goals at Hyperledger in the future is to have less disjointed projects, and more libraries that can be used together as components. With that vision in mind, Hyperledger Iroha wants to eventually provide the following C++ components that can be used by other Hyperledger projects:</p>
<h3 id="relationship-to-hyperledger-fabric-and-hyperledger-sawtooth">Relationship to Hyperledger Fabric and Hyperledger Sawtooth</h3>
<ul>
<li>YAC consensus library</li>
<li>Ed25519 digital signature library</li>
<li>SHA-3 hashing library</li>
<li>Iroha transaction serialization library</li>
<li>P2P communication library</li>
<li>iOS library</li>
<li>Android library</li>
<li>JavaScript library</li>
<li>Blockchain explorer/data visualization suite.</li>
</ul>
<hr>
<h1 id="chapter-6-introduction-to-hyperledger-sawtooth">Chapter 6. Introduction to Hyperledger Sawtooth</h1>
<h3 id="featured-hyperledger-sawtooth-elements">Featured Hyperledger Sawtooth Elements</h3>
<ul>
<li><p><strong>Transaction validators</strong> validate transactions.</p>
</li>
<li><p><strong>Transaction families</strong> are smart contracts in Hyperledger Sawtooth. They define the operations that can be applied to transactions. Transaction families consist of both transaction processors (the server-side logic) and clients (for use from Web or mobile applications).</p>
</li>
<li><p><strong>Transaction processor</strong> is the server-side business logic of transaction families that acts upon network assets.</p>
</li>
<li><p><strong>Transaction batches</strong> are clusters of transactions that are either all committed to state or are all not committed to state.</p>
</li>
<li><p><strong>The network layer</strong> is responsible for communicating between validators in a Hyperledger Sawtooth network, including performing initial connectivity, peer discovery, and message handling.</p>
</li>
<li><p><strong>Global state</strong> contains the current state of the ledger and a chain of transaction invocations. The state for all transaction families is represented on each validator. The process of block validation on each validator ensures that the same transactions result in the same state transitions, and that the resulting data is the same for all participants in the network. The state is split into namespaces, which allow flexibility for transaction family authors to define, share, and reuse global state data between transaction processors.</p>
</li>
</ul>
<h3 id="architecture">Architecture</h3>
<h4 id="consensus">Consensus</h4>
<p>After a batch of many transactions is submitted to the network, the network’s consensus algorithm is run to choose a node to publish the transaction block. By default, the Proof of Elapsed Time consensus algorithm is used, and the transaction validator with the shortest wait time publishes the transaction block. The transaction block is then broadcast to the publishing nodes.</p>
<p>Each node within the network receives the transaction block, and validators verify whether the transaction is valid or not. If the transaction is validated, the global state is updated.</p>
<p>Hyperledger Sawtooth is unique because of its distributed state agreement, whereby every node in the system has the same understanding of information, and, as the supply chain matures, the data stored remains consistent across the network.</p>
<h4 id="transaction-batching">Transaction Batching</h4>
<p>Hyperledger Sawtooth <strong>transaction batches</strong> are clusters of transactions that are either all committed to state together, or none of the transactions are committed at all. As a result, transaction batches are often described as an atomic unit of change, since a group of transactions are treated as one, and are committed to the state as one. Every single transaction in Hyperledger Sawtooth is submitted within a batch. Batches can contain as little as a single transaction.</p>
<p>When a transaction is created by a client, the batch is submitted to the validator (which we will cover more in depth in the next section). Transactions are organized into a batch in the order they are intended to be committed. The validator then, in turn, applies each transaction within the batch, leading to a change in the global state. The batch is committed to the state. If one transaction within the batch is invalid, then none of the transactions within that batch are committed.</p>
<p>In summary, transaction batching allows a group of transactions to be applied in a specific order, and if any are invalid, then none of the transactions are applied. This is a powerful tool that can be utilized by many enterprise solutions, as it provides greater efficiency and control for end users.</p>
<h4 id="validators">Validators</h4>
<p>In any blockchain network, modifying the global state requires creating and applying a transaction. In Hyperledger Sawtooth, <strong>validators</strong> apply blocks that cause a change in the state. More specifically, validators validate transaction blocks, and ensure that transactions result in state changes that are consistent across all participants in the network.</p>
<p>To start, a user creates a transaction batch and submits it to a validator via a client and REST API. The validator then checks the transaction batch and applies it if it is considered valid, resulting in a change to the state. In terms of our demonstrated scenario, Sarah, the fisherman, creates a transaction batch to record information about a group of tuna catches. The validator would then apply the transactions, and the state would be updated if all appropriate attributes are present: a unique ID number, location and time of the catch, weight, and who caught the fish. If any of these elements are missing, the transactions within the batch would not be applied, and the state would not be updated.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/c7b3d5552070184b7b56fc25d316f585/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Sawtooth_validators.png" alt="validators-sawtooth">
</div>

<h4 id="journal">Journal</h4>
<p>In Hyperledger Sawtooth, the journal maintains and extends the blockchain for the validator. It is responsible for validating candidate blocks, evaluating valid blocks to determine if they are the correct chain head, and generating new blocks to extend the chain. Transaction batches arrive at the journal, where they are evaluated, validated, and added to the blockchain. Additionally, the journal resolves forks, which occur due to disagreements over who commits a block. Once blocks are completed, they are delivered to the ChainController for validation and fork resolution.</p>
<p>Consensus in Hyperledger Sawtooth is modular, meaning that the consensus algorithm can be easily modified. Hyperledger Sawtooth provides an abstract interface that supports both PBFT and Nakamoto-style algorithms. To implement a new consensus algorithm in Hyperledger Sawtooth, you must implement the distinct interface for: block publisher, block verifier, and fork resolution.</p>
<ul>
<li><strong>Block publisher:</strong> Creates new candidate blocks to extend the chain.</li>
<li><strong>Block verifier:</strong> Verifies that candidate blocks are published in accordance with consensus rules.</li>
<li><strong>Fork resolver:</strong> Chooses which fork to use as the chain head for consensus algorithms that result in a fork.</li>
</ul>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/a6cfe922dbd88b452ce58d493273f9e4/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Consensus_interface.png" alt="">
</div>

<h4 id="transaction-families">Transaction families</h4>
<p>As with any blockchain framework, transaction updates need to be approved and shared between many untrusted parties. As such, many blockchain frameworks have a mechanism for supporting distributed ledgers, as well as a method for changing the state of the shared ledger.</p>
<p>In Hyperledger Sawtooth, the data model that captures the state and the transaction language that changes the state are implemented using <strong>transaction families</strong>.</p>
<p>A transaction family consists of a group of operations or transaction types that are allowed on the shared ledgers. This allows for flexibility in the level of versatility and risk that exists on a network. Transaction families are often called &#39;safer&#39; smart contracts, because they specify a predefined set of acceptable smart contract templates, as opposed to programming smart contracts from scratch.</p>
<p>Hyperledger Sawtooth’s transaction families can be written in many languages, including Javascript, Java, C++, Python, and Go, which allows flexibility for businesses to bring their own transaction families. Hyperledger Sawtooth allows the developers to specify the address/namespace of data, which provides flexibility in defining, sharing, and reusing data between different transaction families.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/8f6a37e9af4a9e8117c7d1b779e0b405/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Transaction_families.png" alt="sawtooth-transaction-families">
</div>

<h4 id="transaction-processor">Transaction Processor</h4>
<p>A <strong>transaction processor</strong> provides the server-side business logic that operates on assets within a network. Hyperledger Sawtooth supports pluggable transaction processors, that are customizable based on the specific application. Businesses are able to develop transaction processors that do exactly what their applications need. Additionally, transaction processors can be written in a variety of languages (Java, Python, C, C++, JavaScript, and Go), allowing for ease of use and simplicity when handling assets.</p>
<p>Each node within the Hyperledger Sawtooth network runs a transaction processor. This transaction processor processes incoming transactions submitted by authorized clients. In Hyperledger Sawtooth, the Sawtooth SDK allows programmers to focus on developing application logic, as opposed to building communication mechanisms between transaction processors.</p>
<h4 id="sawtooth-node">Sawtooth Node</h4>
<p>Hyperledger Sawtooth organizations run a node that interacts with the Hyperledger Sawtooth network. Each node runs at least three things:</p>
<ul>
<li>The main <strong>validator</strong> process</li>
<li>The <strong>REST service</strong> listening for requests (could be transaction posts or state queries)</li>
<li>One or more <strong>transaction processors</strong></li>
</ul>
<p>Each organization that enters the Hyperledger Sawtooth network runs at least one node, and receives transactions submitted by fellow nodes.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/274566f591da0f1ee0ea5035f5415a7e/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Sawtooth_node.png" alt="Sawtooth-node">
</div>

<hr>
<h1 id="chapter-7-introduction-to-hyperledger-fabric">Chapter 7. Introduction to Hyperledger Fabric</h1>
<h3 id="featured-hyperledger-fabric-elements">Featured Hyperledger Fabric Elements</h3>
<ul>
<li><strong>Channels</strong> are data partitioning mechanisms that allow transaction visibility for stakeholders only. Each channel is an independent chain of transaction blocks containing only transactions for that particular channel.</li>
<li>The <strong>chaincode</strong> (Smart Contracts) encapsulates both the asset definitions and the business logic (or transactions) for modifying those assets. Transaction invocations result in changes to the ledger.</li>
<li>The <strong>ledger</strong> contains the current world state of the network and a chain of transaction invocations. A shared, permissioned ledger is an append-only system of records and serves as a single source of truth.</li>
<li>The <strong>network</strong> is the collection of data processing peers that form a blockchain network. The network is responsible for maintaining a consistently replicated ledger.</li>
<li>The <strong>ordering service</strong> is a collection of nodes that orders transactions into a block.</li>
<li>The <strong>world state</strong> reflects the current data about all the assets in the network. This data is stored in a database for efficient access. Current supported databases are LevelDB and CouchDB.</li>
<li>The <strong>membership service provider</strong> (MSP) manages identity and permissioned access for clients and peers.</li>
</ul>
<h3 id="architecture">Architecture</h3>
<h4 id="roles">Roles</h4>
<p>There are three different types of roles within a Hyperledger Fabric network:</p>
<ul>
<li><p><strong>Clients</strong></p>
<p>Clients are applications that act on behalf of a person to propose transactions on the network.</p>
</li>
<li><p><strong>Peers</strong></p>
<p>Peers maintain the state of the network and a copy of the ledger. There are two different types of peers: <strong>endorsing</strong> and <strong>committing</strong> peers. However, there is an overlap between endorsing and committing peers, in that endorsing peers are a special kind of committing peers. All peers commit blocks to the distributed ledger.</p>
<ul>
<li>Endorsers simulate and endorse transactions</li>
<li>Committers verify endorsements and validate transaction results, prior to committing transactions to the blockchain.</li>
</ul>
</li>
<li><p><strong>Ordering Service</strong></p>
<p>The ordering service accepts endorsed transactions, orders them into a block, and delivers the blocks to the committing peers.</p>
</li>
</ul>
<h4 id="consensus">Consensus</h4>
<p>In Hyperledger Fabric, consensus is made up of three distinct steps:</p>
<ul>
<li>Transaction endorsement</li>
<li>Ordering</li>
<li>Validation and commitment.</li>
</ul>
<p>These three steps ensure the policies of a network are upheld.</p>
<h3 id="transaction-flow">Transaction Flow</h3>
<p><strong>Step 1:</strong> Within a Hyperledger Fabric network, transactions start out with client applications sending transaction proposals, or, in other words, proposing a transaction to endorsing peers.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/21431955acd5b7888ca8d393c94deaf8/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Key_Components_-_Transaction_Proposal.png" alt="Step 1 of Fabric transaction flow">
</div>

<p>Client applications are commonly referred to as applications or clients, and allow people to communicate with the blockchain network.</p>
<p><strong>Step 2:</strong> Each endorsing peer simulates the proposed transaction, without updating the ledger. The endorsing peers will capture the set of <strong>R</strong> ead and <strong>W</strong> ritten data, called <strong>RW Sets</strong>. These RW sets capture what was read from the current world state while simulating the transaction, as well as what would have been written to the world state had the transaction been executed. These RW sets are then signed by the endorsing peer, and returned to the client application to be used in future steps of the transaction flow.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/13e5a6a80c0e150f46d45ec0634b86b8/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Transaction_flow_step_2.png" alt="Step 2 of Fabric transaction flow">
</div>
Endorsing peers must hold smart contracts in order to simulate the transaction proposals.

<strong>Step 3:</strong> The application then submits the endorsed transaction and the RW sets to the ordering service. Ordering happens across the network, in parallel with endorsed transactions and RW sets submitted by other applications.
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/b6e7b13624d1cff4152e2c223538c355/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Transaction_flow_step_3.png" alt="Step 3 of Fabric transaction flow">
</div>

<p><strong>Step 4:</strong> The ordering service takes the endorsed transactions and RW sets, orders this information into a block, and delivers the block to all committing peers.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/eeb54ce57f8a6018443e22f34b3ebad9/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Transaction_Flow_Step_4.png" alt="Step 4 of Fabric transaction flow">
</div>

<p>The ordering service, which is made up of a cluster of orderers, does not process transactions, smart contracts, or maintains the shared ledger. The ordering service accepts the endorsed transactions and specifies the order in which those transactions will be committed to the ledger. The Fabric v1.0 architecture has been designed such that the specific implementation of &#39;ordering&#39; (Solo, Kafka, BFT) becomes a pluggable component. The default ordering service for Hyperledger Fabric is Kafka. Therefore, the ordering service is a modular component of Hyperledger Fabric.</p>
<p><strong>Step 5:</strong> The committing peer validates the transaction by checking to make sure that the RW sets still match the current world state. Specifically, that the Read data that existed when the endorsers simulated the transaction is identical to the current world state. When the committing peer validates the transaction, the transaction is written to the ledger, and the world state is updated with the Write data from the RW Set.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/b05e5430900cf5e414e307d2f99de088/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Transaction_Flow_Step_5.png" alt="Step 5 of Fabric transaction flow">
</div>

<p>If the transaction fails, that is, if the committing peer finds that the RW set does not match the current world state, the transaction ordered into a block will still be included in that block, but it will be marked as invalid, and the world state will not be updated.</p>
<p>Committing peers are responsible for adding blocks of transactions to the shared ledger and updating the world state. They may hold smart contracts, but it is not a requirement.</p>
<p><strong>Step 6:</strong> Lastly, the committing peers asynchronously notify the client application of the success or failure of the transaction. Applications will be notified by each committing peer.</p>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/ba380b73a55eff97c85da3abdc1d86e8/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Transaction_Flow_Step_6.png" alt="Step 6 of Fabric transaction flow">
</div>

<p><strong>Summary:</strong></p>
<p>Endorsing peers verify the client signature, and execute a chaincode function to simulate the transaction. The output is the chaincode results, a set of key/value versions that were read in the chaincode (Read set), and the set of keys/values that were written by the chaincode. The proposal response gets sent back to the client, along with an endorsement signature. These proposal responses are sent to the orderer to be ordered. The orderer then orders the transactions into a block, which it forwards to the endorsing and committing peers. The RW sets are used to verify that the transactions are still valid before the content of the ledger and world state is updated. Finally, the peers asynchronously notify the client application of the success or failure of the transaction.</p>
<h4 id="transaction-endorsement">Transaction Endorsement</h4>
<p>A transaction endorsement is a signed response to the results of the simulated transaction. The method of transaction endorsements depends on the endorsement policy which is specified when the chaincode is deployed. An example of an endorsement policy would be &quot;the majority of the endorsing peers must endorse the transaction&quot;. Since an endorsement policy is specified for a specific chaincode, different channels can have different endorsement policies.</p>
<h4 id="ordering">Ordering</h4>
<p>In a blockchain network, transactions have to be written to the shared ledger in a consistent order. The order of transactions has to be established to ensure that the updates to the world state are valid when they are committed to the network. Unlike the Bitcoin blockchain, where ordering occurs through the solving of a cryptographic puzzle, or mining, Hyperledger Fabric allows the organizations running the network to choose the ordering mechanism that best suits that network. This modularity and flexibility makes Hyperledger Fabric incredibly advantageous for enterprise applications.</p>
<p>Hyperledger Fabric provides three ordering mechanisms: SOLO, Kafka, and Simplified Byzantine Fault Tolerance (SBFT), the latter of which has not yet been implemented in Fabric v1.0.</p>
<ul>
<li><strong>SOLO</strong> is the Hyperledger Fabric ordering mechanism most typically used by developers experimenting with Hyperledger Fabric networks. SOLO involves a single ordering node.</li>
<li><strong>Kafka</strong> is the Hyperledger Fabric ordering mechanism that is recommended for production use. This ordering mechanism utilizes Apache Kafka, an open source stream processing platform that provides a unified, high-throughput, low-latency platform for handling real-time data feeds. In this case, the data consists of endorsed transactions and RW sets. The Kafka mechanism provides a crash fault-tolerant solution to ordering.</li>
<li><strong>SBFT</strong> stands for Simplified Byzantine Fault Tolerance. This ordering mechanism is both crash fault-tolerant and byzantine fault-tolerant, meaning that it can reach agreement even in the presence of malicious or faulty nodes. The Hyperledger Fabric community has not yet implemented this mechanism, but it is on their roadmap.</li>
</ul>
<h4 id="identity-verification">Identity Verification</h4>
<p>In addition to the multitude of endorsement, validity, and versioning checks that take place, there are also ongoing identity verifications happening during each step of the transaction flow. Access control lists are implemented on the hierarchical layers of the network (from the ordering service down to channels), and payloads are repeatedly signed, verified, and authenticated as a transaction proposal passes through the different architectural components.</p>
<h2 id="channels">Channels</h2>
<p>Channels allow organizations to utilize the same network, while maintaining separation between multiple blockchains. Only the members of the channel on which the transaction was performed can see the specifics of the transaction. In other words, channels partition the network in order to allow transaction visibility for stakeholders only. This mechanism works by delegating transactions to different ledgers. Only the members of the channel are involved in consensus, while other members of the network do not see the transactions on the channel.</p>
<p><img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/b23a6aaaa627620a0ab161c556ff87b3/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/Key_Components_Channels.png" alt="channels"></p>
<p>Peers can belong to multiple networks or channels. Peers that do participate in multiple channels simulate and commit transactions to different ledgers. The ordering service is the same across any network or channel.</p>
<p>A few things to remember:</p>
<ul>
<li>The network setup allows for the creation of channels.</li>
<li>The same chaincode logic can be applied to multiple channels.</li>
<li>A given user can participate in multiple channels.</li>
</ul>
<h2 id="state-database">State Database</h2>
<h2 id="smart-contracts">Smart Contracts</h2>
<p>Smart contracts are computer programs that contain logic to execute transactions and modify the state of the assets stored within the ledger. Hyperledger Fabric smart contracts are called chaincode and are written in Go. The chaincode serves as the business logic for a Hyperledger Fabric network, in that the chaincode directs how you manipulate assets within the network.</p>
<p>There are two ways to develop smart contracts with Hyperledger Fabric:</p>
<ul>
<li>Code individual contracts into standalone instances of chaincode</li>
<li>(More efficient way) Use chaincode to create decentralized applications that manage the lifecycle of one or multiple types of business contracts, and let the end users instantiate instances of contracts within these applications.</li>
</ul>
<h3 id="chaincode">Chaincode</h3>
<p>When creating a chaincode, there are two methods that you will need to implement:</p>
<ul>
<li><strong>Init</strong>
Called when a chaincode receives an instantiate or upgrade transaction. This is where you will initialize any application state.</li>
<li><strong>Invoke</strong>
Called when the invoke transaction is received to process any transaction proposals.</li>
</ul>
<p>As a developer, you must create both an Init and an Invoke method within your chaincode. The chaincode must be installed using the peer chaincode install command, and instantiated using the peer chaincode instantiate command before the chaincode can be invoked. Then, transactions can be created using the peer chaincode invoke or peer chaincode query commands.</p>
<h2 id="application-flow-basics">Application Flow Basics</h2>
<div style="text-align: center">
<img src="https://prod-edxapp.edx-cdn.org/assets/courseware/v1/a63eaf4dd007c3e65ee63955eccaf5b6/asset-v1:LinuxFoundationX+LFS171x+3T2017+type@asset+block/fabric-application-flowbasics.png" alt="App flow basics">
</div></body>
</html>
